<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Battle Arena</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #0d0d15;
            --primary-blue: #00f0ff;
            --secondary-purple: #bc13fe;
            --text-color: #e0e0e0;
            --panel-bg: rgba(20, 20, 35, 0.98);
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex; flex-direction: column; height: 100vh;
            user-select: none; -webkit-user-select: none;
        }

        /* --- UI COMPONENTS --- */
        .screen {
            display: none; flex: 1; flex-direction: column;
            align-items: center; justify-content: center;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }
        .screen.active { display: flex; }

        .neon-text {
            text-shadow: 0 0 10px var(--primary-blue);
            color: #fff; font-size: 2rem; margin-bottom: 20px; font-weight: bold;
        }

        .btn {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 2px solid var(--primary-blue);
            color: var(--primary-blue);
            padding: 12px 20px; margin: 8px; font-size: 1.1rem;
            cursor: pointer; width: 80%; max-width: 300px;
            text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.2);
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); background: var(--primary-blue); color: #000; }
        
        .btn-bet { width: auto; display: inline-block; padding: 10px; margin: 5px; min-width: 60px; }
        .btn-bet.selected { background: var(--primary-blue); color: #000; }

        .profile-card {
            background: var(--panel-bg); border: 1px solid var(--secondary-purple);
            padding: 20px; border-radius: 10px; width: 85%; margin-bottom: 10px;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 8px 0; border-bottom: 1px dashed #444; }

        /* --- GAME CANVAS --- */
        canvas {
            border: 2px solid var(--primary-blue); background-color: #000;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.2);
            image-rendering: pixelated; /* Retro look */
            display: block; margin: 0 auto;
        }

        .game-header { width: 90%; display: flex; justify-content: space-between; margin-bottom: 10px; }

        /* --- CONTROLS --- */
        .controls {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            margin-top: 15px; width: 240px;
        }
        .ctrl-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid var(--primary-blue);
            height: 60px; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; font-size: 24px; color: white;
        }
        .ctrl-btn:active { background: var(--primary-blue); }

        /* --- MODALS --- */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .modal-content {
            background: var(--panel-bg); padding: 20px; border: 2px solid var(--primary-blue);
            text-align: center; width: 80%;
        }

        /* --- TABS --- */
        .nav-tabs {
            position: fixed; bottom: 0; width: 100%; height: 60px;
            display: flex; background: var(--panel-bg); border-top: 2px solid var(--secondary-purple);
            z-index: 50;
        }
        .tab { flex: 1; display: flex; align-items: center; justify-content: center; color: #888; font-size: 1.2rem; }
        .tab.active { color: var(--primary-blue); text-shadow: 0 0 5px var(--primary-blue); }
    </style>
</head>
<body>

<div id="app">
    <!-- MENU SCREEN -->
    <div id="screen-menu" class="screen active">
        <h1 class="neon-text">RETRO ARENA</h1>
        <div id="duel-info" style="color: #ff0055; margin-bottom: 15px; font-weight: bold;"></div>
        
        <button class="btn" onclick="launchGame('snake', false)">üêç SNAKE (–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞)</button>
        <button class="btn" onclick="launchGame('tetris', false)">üß± TETRIS (–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞)</button>
        <hr style="width: 80%; border-color: #333;">
        <button class="btn" style="border-color: var(--secondary-purple); color: var(--secondary-purple);" onclick="openBetModal()">‚öîÔ∏è –î–£–≠–õ–¨ (PvP)</button>
    </div>

    <!-- PROFILE SCREEN -->
    <div id="screen-profile" class="screen">
        <h2 class="neon-text">–ü–†–û–§–ò–õ–¨</h2>
        <div class="profile-card">
            <div class="stat-row"><span>ID:</span> <span id="p-id">...</span></div>
            <div class="stat-row"><span>–ë–∞–ª–∞–Ω—Å:</span> <span id="p-balance" style="color: gold;">0 ‚òÖ</span></div>
            <div class="stat-row"><span>Snake Record:</span> <span id="p-snake">0</span></div>
            <div class="stat-row"><span>Tetris Record:</span> <span id="p-tetris">0</span></div>
        </div>
        
        <div class="profile-card" style="text-align: center;">
            <p style="margin: 0 0 10px 0;">–ü–æ–ø–æ–ª–Ω–∏—Ç—å Stars:</p>
            <div>
                <button class="btn btn-bet" onclick="buyStars(10)">10</button>
                <button class="btn btn-bet" onclick="buyStars(50)">50</button>
                <button class="btn btn-bet" onclick="buyStars(100)">100</button>
                <button class="btn btn-bet" onclick="buyStars(500)">500</button>
                <button class="btn btn-bet" onclick="buyStars(1000)">1K</button>
            </div>
        </div>

        <button class="btn" style="border-color: red; color: red;" onclick="withdrawStars()">–í–´–í–ï–°–¢–ò –í–°–ï STARS</button>
    </div>

    <!-- GAME SCREEN -->
    <div id="screen-game" class="screen" style="justify-content: flex-start; padding-top: 20px;">
        <div class="game-header">
            <span id="game-title">GAME</span>
            <span id="score-display" style="color: gold;">SCORE: 0</span>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div class="controls">
            <div class="ctrl-btn" style="grid-column: 1;" ontouchstart="handleInput('left', event)" onmousedown="handleInput('left', event)">‚Üê</div>
            <div class="ctrl-btn" style="grid-column: 2;" ontouchstart="handleInput('up', event)" onmousedown="handleInput('up', event)">‚Üª</div>
            <div class="ctrl-btn" style="grid-column: 3;" ontouchstart="handleInput('right', event)" onmousedown="handleInput('right', event)">‚Üí</div>
            <div class="ctrl-btn" style="grid-column: 2;" ontouchstart="handleInput('down', event)" onmousedown="handleInput('down', event)">‚Üì</div>
        </div>
    </div>
</div>

<!-- BET MODAL -->
<div id="bet-modal" class="modal">
    <div class="modal-content">
        <h3 style="color: var(--primary-blue);">–í–´–ë–ï–†–ò –°–¢–ê–í–ö–£</h3>
        <div id="bet-options-container">
            <button class="btn btn-bet selected" onclick="selectBet(10, this)">10</button>
            <button class="btn btn-bet" onclick="selectBet(50, this)">50</button>
            <button class="btn btn-bet" onclick="selectBet(100, this)">100</button>
            <button class="btn btn-bet" onclick="selectBet(500, this)">500</button>
            <button class="btn btn-bet" onclick="selectBet(1000, this)">1000</button>
        </div>
        <p style="font-size: 0.8rem; color: #888;">–ö–æ–º–∏—Å—Å–∏—è 10% –æ—Ç –±–∞–Ω–∫–∞.</p>
        <button class="btn" onclick="createDuel()">–°–û–ó–î–ê–¢–¨ –°–°–´–õ–ö–£</button>
        <button class="btn" style="border-color: red; color: red;" onclick="document.getElementById('bet-modal').style.display='none'">–û–¢–ú–ï–ù–ê</button>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div id="game-over-modal" class="modal">
    <div class="modal-content">
        <h2 style="color: red;">GAME OVER</h2>
        <h3 id="final-score">Score: 0</h3>
        <p id="pvp-message" style="color: gold;"></p>
        <button class="btn" onclick="location.reload()">–í –ú–ï–ù–Æ</button>
    </div>
</div>

<!-- NAV TABS -->
<div class="nav-tabs">
    <div class="tab active" onclick="showScreen('menu'); updateTab(this)">–ê–†–ï–ù–ê</div>
    <div class="tab" onclick="showScreen('profile'); updateTab(this)">–ü–†–û–§–ò–õ–¨</div>
</div>

<script>
    // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
    const API_URL = "https://tg-game-arena.onrender.com";
    const tg = window.Telegram.WebApp;
    tg.ready(); tg.expand();
    tg.setHeaderColor('#0d0d15'); tg.setBackgroundColor('#0d0d15');

    // --- –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
    let currentUser = null;
    let currentLobby = null;
    let selectedBetAmount = 10;
    let gameLoop = null;
    let currentGameName = '';
    let score = 0;

    // --- –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ---
    async function init() {
        try {
            // 1. –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
            const res = await fetch(`${API_URL}/api/user-data`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ initData: tg.initData })
            });
            currentUser = await res.json();
            updateProfile();

            // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ deep link (–≤—Ö–æ–¥ –≤ –¥—É—ç–ª—å)
            const startParam = tg.initDataUnsafe.start_param;
            if (startParam) {
                const joinRes = await fetch(`${API_URL}/api/join-lobby`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ telegramId: currentUser.telegramId, startParam })
                });
                const joinData = await joinRes.json();
                
                if (joinData.error) {
                    tg.showAlert(joinData.error);
                } else if (joinData.mode === 'duel') {
                    currentLobby = joinData.lobby;
                    document.getElementById('duel-info').innerText = `üî• –î–£–≠–õ–¨: ${currentLobby.betAmount} STARS`;
                    // –°—Ä–∞–∑—É –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –∏–≥—Ä–∞—Ç—å –≤ –¢–µ—Ç—Ä–∏—Å –¥–ª—è –¥—É—ç–ª–∏ (–º–æ–∂–Ω–æ —É—Å–ª–æ–∂–Ω–∏—Ç—å –≤—ã–±–æ—Ä)
                    launchGame('tetris', true);
                }
            }
        } catch (e) { console.error("Init Error:", e); }
    }
    init();

    // --- –ò–ù–¢–ï–†–§–ï–ô–° ---
    function showScreen(name) {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById(`screen-${name}`).classList.add('active');
        document.querySelector('.nav-tabs').style.display = (name === 'game') ? 'none' : 'flex';
        if (name !== 'game') stopGame();
    }

    function updateTab(el) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        el.classList.add('active');
    }

    function updateProfile() {
        if (!currentUser) return;
        document.getElementById('p-id').innerText = currentUser.telegramId;
        document.getElementById('p-balance').innerText = `${currentUser.balance} ‚òÖ`;
        document.getElementById('p-snake').innerText = currentUser.highScores.snake;
        document.getElementById('p-tetris').innerText = currentUser.highScores.tetris;
    }

    // --- –ü–õ–ê–¢–ï–ñ–ò –ò –°–¢–ê–í–ö–ò ---
    function openBetModal() { document.getElementById('bet-modal').style.display = 'flex'; }
    
    function selectBet(amt, btn) {
        selectedBetAmount = amt;
        document.querySelectorAll('.btn-bet').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
    }

    async function createDuel() {
        if (currentUser.balance < selectedBetAmount) return tg.showAlert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ Stars!");
        
        try {
            const res = await fetch(`${API_URL}/api/create-lobby`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, betAmount: selectedBetAmount })
            });
            const data = await res.json();
            if (data.success) {
                const link = `https://t.me/share/url?url=https://t.me/RetroBattleBot/app?startapp=${data.lobbyId}&text=–°—Ä–∞–∑–∏—Å—å —Å–æ –º–Ω–æ–π –≤ –¢–µ—Ç—Ä–∏—Å –Ω–∞ ${selectedBetAmount} Stars!`;
                tg.openTelegramLink(link);
            }
        } catch (e) { tg.showAlert("–û—à–∏–±–∫–∞ —Å–µ—Ç–∏"); }
    }

    async function buyStars(amount) {
        try {
            const res = await fetch(`${API_URL}/api/create-invoice`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ amount })
            });
            const data = await res.json();
            if (data.invoiceLink) tg.openInvoice(data.invoiceLink);
        } catch (e) { tg.showAlert("–û—à–∏–±–∫–∞ –ø–ª–∞—Ç–µ–∂–∞"); }
    }

    async function withdrawStars() {
        if (!confirm("–í—ã–≤–µ—Å—Ç–∏ –≤—Å–µ —Å—Ä–µ–¥—Å—Ç–≤–∞?")) return;
        try {
            const res = await fetch(`${API_URL}/api/withdraw`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId })
            });
            const data = await res.json();
            if (data.success) {
                tg.showAlert(`–ó–∞—è–≤–∫–∞ –Ω–∞ –≤—ã–≤–æ–¥ ${data.amount} Stars —Å–æ–∑–¥–∞–Ω–∞!`);
                currentUser.balance = 0;
                updateProfile();
            } else { tg.showAlert(data.error); }
        } catch (e) { tg.showAlert("–û—à–∏–±–∫–∞ —Å–µ—Ç–∏"); }
    }

    // --- –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è —Ä–µ—Ç—Ä–æ-–≤–∏–¥–∞
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 24; // –ü–∏–∫—Å–µ–ª–µ–π –Ω–∞ –±–ª–æ–∫
    canvas.width = COLS * BLOCK_SIZE;
    canvas.height = ROWS * BLOCK_SIZE;

    function launchGame(gameName, isPvP) {
        currentGameName = gameName;
        showScreen('game');
        document.getElementById('game-title').innerText = isPvP ? "PVP DUEL" : gameName.toUpperCase();
        document.getElementById('game-over-modal').style.display = 'none';
        score = 0;
        document.getElementById('score-display').innerText = `SCORE: 0`;

        if (gameName === 'snake') startSnake();
        if (gameName === 'tetris') startTetris();
    }

    function stopGame() {
        if (gameLoop) cancelAnimationFrame(gameLoop);
        clearTimeout(gameLoop);
    }

    async function gameOver() {
        stopGame();
        document.getElementById('final-score').innerText = `Score: ${score}`;
        const msgEl = document.getElementById('pvp-message');
        
        if (currentLobby) {
            msgEl.innerText = "–†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...";
            await fetch(`${API_URL}/api/submit-score`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    telegramId: currentUser.telegramId,
                    game: currentGameName,
                    score: score,
                    lobbyId: currentLobby.lobbyId
                })
            });
            msgEl.innerText = "–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω! –ï—Å–ª–∏ –ø–æ–±–µ–¥–∏–ª - –Ω–∞–≥—Ä–∞–¥–∞ –ø—Ä–∏–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.";
        } else {
            msgEl.innerText = "–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –æ–∫–æ–Ω—á–µ–Ω–∞.";
            // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∫–æ—Ä–¥ —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏
            await fetch(`${API_URL}/api/submit-score`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, game: currentGameName, score: score })
            });
        }
        
        document.getElementById('game-over-modal').style.display = 'flex';
    }

    function handleInput(action, e) {
        if(e) e.preventDefault();
        const event = new KeyboardEvent('keydown', {
            'key': action === 'up' ? 'ArrowUp' : 
                   action === 'down' ? 'ArrowDown' :
                   action === 'left' ? 'ArrowLeft' : 'ArrowRight'
        });
        document.dispatchEvent(event);
    }

    // ==========================================
    // –î–í–ò–ñ–û–ö TETRIS (–ü–û–õ–ù–û–°–¢–¨–Æ –†–ê–ë–û–ß–ò–ô)
    // ==========================================
    function startTetris() {
        let board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
        
        const SHAPES = [
            [],
            [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], // I (Cyan)
            [[1,0,0],[1,1,1],[0,0,0]], // J (Blue)
            [[0,0,1],[1,1,1],[0,0,0]], // L (Orange)
            [[0,1,1],[0,1,1]],         // O (Yellow)
            [[0,1,1],[1,1,0],[0,0,0]], // S (Green)
            [[0,1,0],[1,1,1],[0,0,0]], // T (Purple)
            [[1,1,0],[0,1,1],[0,0,0]]  // Z (Red)
        ];
        
        const COLORS = [null, '#00f0ff', '#0000ff', '#ff8800', '#ffff00', '#00ff00', '#bc13fe', '#ff0000'];

        let piece = newPiece();
        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;

        function newPiece() {
            const id = Math.ceil(Math.random() * 7);
            const matrix = SHAPES[id];
            return {
                matrix: matrix,
                x: Math.floor(COLS / 2) - Math.floor(matrix[0].length / 2),
                y: 0,
                color: COLORS[id]
            };
        }

        function drawMatrix(matrix, offset, color) {
            ctx.fillStyle = color;
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        ctx.strokeStyle = '#000';
                        ctx.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                });
            });
        }

        function draw() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Board
            board.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        ctx.fillStyle = COLORS[value];
                        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                    }
                });
            });

            // Draw Piece
            drawMatrix(piece.matrix, {x: piece.x, y: piece.y}, piece.color);
        }

        function collide(arena, player) {
            const m = player.matrix;
            const o = {x: player.x, y: player.y};
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0 &&
                       (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(arena, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        arena[y + player.y][x + player.x] = SHAPES.findIndex(s => s === player.matrix) || 1; // Simplification for color saving
                        // Hacky way to save color index properly, better use id in piece object
                         // Let's rely on non-zero check in board draw
                         if (player.color === '#00f0ff') arena[y + player.y][x + player.x] = 1;
                         else if (player.color === '#0000ff') arena[y + player.y][x + player.x] = 2;
                         else if (player.color === '#ff8800') arena[y + player.y][x + player.x] = 3;
                         else if (player.color === '#ffff00') arena[y + player.y][x + player.x] = 4;
                         else if (player.color === '#00ff00') arena[y + player.y][x + player.x] = 5;
                         else if (player.color === '#bc13fe') arena[y + player.y][x + player.x] = 6;
                         else arena[y + player.y][x + player.x] = 7;
                    }
                });
            });
        }

        function rotate(matrix) {
            for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            matrix.forEach(row => row.reverse());
        }

        function playerDrop() {
            piece.y++;
            if (collide(board, piece)) {
                piece.y--;
                merge(board, piece);
                arenaSweep();
                piece = newPiece();
                if (collide(board, piece)) {
                    gameOver();
                }
            }
            dropCounter = 0;
        }

        function playerMove(dir) {
            piece.x += dir;
            if (collide(board, piece)) {
                piece.x -= dir;
            }
        }

        function playerRotate() {
            const pos = piece.x;
            rotate(piece.matrix);
            if (collide(board, piece)) {
                piece.x = pos;
                rotate(piece.matrix); // Rotate back
                rotate(piece.matrix);
                rotate(piece.matrix);
            }
        }

        function arenaSweep() {
            outer: for (let y = board.length - 1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) {
                    if (board[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
                score += 100;
                document.getElementById('score-display').innerText = `SCORE: ${score}`;
            }
        }

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                playerDrop();
            }
            draw();
            gameLoop = requestAnimationFrame(update);
        }

        // Input handler wrapper
        function keyHandler(e) {
            if (currentGameName !== 'tetris') return;
            if (e.key === 'ArrowLeft') playerMove(-1);
            else if (e.key === 'ArrowRight') playerMove(1);
            else if (e.key === 'ArrowDown') playerDrop();
            else if (e.key === 'ArrowUp') playerRotate();
        }

        document.addEventListener('keydown', keyHandler);
        update();
    }

    // ==========================================
    // –î–í–ò–ñ–û–ö SNAKE (–ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô)
    // ==========================================
    function startSnake() {
        const gridSize = BLOCK_SIZE; // 24px
        const tileCountX = COLS;     // 10
        const tileCountY = ROWS;     // 20
        
        let snake = [{x: 5, y: 10}];
        let food = {x: 2, y: 5};
        let dx = 0;
        let dy = 0;
        
        // –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ (–≥—Ä—É–±—ã–π –º–µ—Ç–æ–¥, –Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è SPA)
        let oldNode = document.body;
        // –ü–µ—Ä–µ–Ω–∞–∑–Ω–∞—á–∞–µ–º —Å–ª—É—à–∞—Ç–µ–ª—å –¥–ª—è –∑–º–µ–π–∫–∏
        document.onkeydown = function(e) {
            if (currentGameName !== 'snake') return;
            switch(e.key) {
                case 'ArrowLeft': if (dx !== 1) { dx = -1; dy = 0; } break;
                case 'ArrowUp': if (dy !== 1) { dx = 0; dy = -1; } break;
                case 'ArrowRight': if (dx !== -1) { dx = 1; dy = 0; } break;
                case 'ArrowDown': if (dy !== -1) { dx = 0; dy = 1; } break;
            }
            // Start game on first keypress
            if (dx === 0 && dy === 0 && (e.key === 'ArrowRight')) { dx = 1; dy = 0; }
        };

        function gameLoopSnake() {
            // Logic
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Wall Collision
            if (head.x < 0 || head.x >= tileCountX || head.y < 0 || head.y >= tileCountY) {
                // –ï—Å–ª–∏ –º—ã –Ω–µ –¥–≤–∏–≥–∞–ª–∏—Å—å (—Å—Ç–∞—Ä—Ç), –Ω–µ —É–±–∏–≤–∞–µ–º
                if (dx !== 0 || dy !== 0) { gameOver(); return; }
                else head.x = snake[0].x; // Hack to stay put
            }
            
            // Self Collision
            for (let i = 0; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y && (dx!==0 || dy!==0)) {
                    gameOver(); return;
                }
            }

            if (dx !== 0 || dy !== 0) {
                snake.unshift(head);
                // Food
                if (head.x === food.x && head.y === food.y) {
                    score += 10;
                    document.getElementById('score-display').innerText = `SCORE: ${score}`;
                    food = {
                        x: Math.floor(Math.random() * tileCountX),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                } else {
                    snake.pop();
                }
            }

            // Draw
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw Food (Red Apple)
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);

            // Draw Snake (Neon Green)
            ctx.fillStyle = '#00f0ff';
            for (let i = 0; i < snake.length; i++) {
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2);
            }
        }

        // 15 FPS for Snake
        if (gameLoop) clearInterval(gameLoop);
        gameLoop = setInterval(gameLoopSnake, 1000 / 10);
    }
</script>
</body>
</html>

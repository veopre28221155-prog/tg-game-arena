<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Battle Arena</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #0d0d15;
            --primary-blue: #00f0ff;
            --secondary-purple: #bc13fe;
            --text-color: #e0e0e0;
            --panel-bg: rgba(20, 20, 35, 0.95);
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            display: flex; flex-direction: column; height: 100vh;
            user-select: none; -webkit-user-select: none;
        }

        /* UI COMPONENTS */
        .screen {
            display: none; flex: 1; flex-direction: column;
            align-items: center; justify-content: center;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }
        .screen.active { display: flex; }

        .neon-text {
            text-shadow: 0 0 10px var(--primary-blue);
            color: #fff; font-size: 2rem; margin-bottom: 20px;
        }

        .btn {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 2px solid var(--primary-blue);
            color: var(--primary-blue);
            padding: 12px 25px; margin: 8px; font-size: 1.1rem;
            cursor: pointer; width: 80%; max-width: 300px;
            text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.2);
        }
        .btn:active { transform: scale(0.96); background: var(--primary-blue); color: #000; }
        .btn-secondary { border-color: var(--secondary-purple); color: var(--secondary-purple); }

        .profile-card {
            background: var(--panel-bg); border: 1px solid var(--secondary-purple);
            padding: 20px; border-radius: 10px; width: 85%;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 8px 0; border-bottom: 1px dashed #444; }

        /* GAME */
        canvas {
            border: 2px solid var(--primary-blue); background-color: #000;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.2);
            image-rendering: pixelated;
        }

        .controls {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            margin-top: 15px; width: 220px;
        }
        .ctrl-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid var(--primary-blue);
            height: 60px; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; font-size: 24px; color: white;
        }
        .ctrl-btn:active { background: var(--primary-blue); }

        /* MODALS */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .modal-content {
            background: var(--panel-bg); padding: 20px; border: 2px solid var(--primary-blue);
            text-align: center; width: 80%;
        }
        .bet-option {
            display: inline-block; padding: 10px; margin: 5px;
            border: 1px solid #555; cursor: pointer;
        }
        .bet-option.selected { background: var(--primary-blue); color: #000; }

        /* TABS */
        .nav-tabs {
            position: fixed; bottom: 0; width: 100%; height: 60px;
            display: flex; background: var(--panel-bg); border-top: 2px solid var(--secondary-purple);
            z-index: 50;
        }
        .tab { flex: 1; display: flex; align-items: center; justify-content: center; color: #888; }
        .tab.active { color: var(--primary-blue); text-shadow: 0 0 5px var(--primary-blue); }
    </style>
</head>
<body>

<div id="app">
    <!-- MENU -->
    <div id="screen-menu" class="screen active">
        <h1 class="neon-text">RETRO ARENA</h1>
        <div id="duel-status" style="color: #ff0055; margin-bottom: 10px;"></div>
        <button class="btn" onclick="startGame('snake')">SNAKE (Тренировка)</button>
        <button class="btn" onclick="startGame('tetris')">TETRIS (Тренировка)</button>
        <button class="btn btn-secondary" onclick="openBetModal()">⚔️ ДУЭЛЬ (Ставки)</button>
    </div>

    <!-- PROFILE -->
    <div id="screen-profile" class="screen">
        <h2 class="neon-text">ПРОФИЛЬ</h2>
        <div class="profile-card">
            <div class="stat-row"><span>Игрок:</span> <span id="p-name">...</span></div>
            <div class="stat-row"><span>Баланс:</span> <span id="p-balance" style="color: gold;">0</span></div>
            <div class="stat-row"><span>Snake Max:</span> <span id="p-snake">0</span></div>
            <div class="stat-row"><span>Tetris Max:</span> <span id="p-tetris">0</span></div>
        </div>
        
        <div style="margin-top: 20px; width: 90%;">
            <label>Пополнить (Stars):</label>
            <select id="deposit-amount" style="width: 100%; padding: 10px; margin: 5px 0; background: #000; color: #fff; border: 1px solid #555;">
                <option value="10">10 ⭐️</option>
                <option value="50">50 ⭐️</option>
                <option value="100">100 ⭐️</option>
                <option value="500">500 ⭐️</option>
                <option value="1000">1000 ⭐️</option>
            </select>
            <button class="btn" style="width: 100%;" onclick="buyStars()">ПОПОЛНИТЬ</button>
        </div>

        <button class="btn btn-secondary" style="margin-top: 10px;" onclick="withdrawFunds()">ВЫВЕСТИ СРЕДСТВА</button>
    </div>

    <!-- GAME -->
    <div id="screen-game" class="screen" style="justify-content: flex-start; padding-top: 20px;">
        <div style="display:flex; justify-content:space-between; width: 90%;">
            <span id="game-info" style="color: #888;">Practice</span>
            <span id="score-board" style="color: var(--primary-blue);">SCORE: 0</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div class="ctrl-btn" style="grid-column: 1;" ontouchstart="handleInput('left', event)">←</div>
            <div class="ctrl-btn" style="grid-column: 2;" ontouchstart="handleInput('up', event)">↻</div>
            <div class="ctrl-btn" style="grid-column: 3;" ontouchstart="handleInput('right', event)">→</div>
            <div class="ctrl-btn" style="grid-column: 2;" ontouchstart="handleInput('down', event)">↓</div>
        </div>
    </div>
</div>

<!-- BET MODAL -->
<div id="bet-modal" class="modal">
    <div class="modal-content">
        <h3>ВЫБЕРИ СТАВКУ</h3>
        <div id="bet-options">
            <div class="bet-option" onclick="selectBet(10)">10</div>
            <div class="bet-option" onclick="selectBet(50)">50</div>
            <div class="bet-option" onclick="selectBet(100)">100</div>
            <div class="bet-option" onclick="selectBet(500)">500</div>
            <div class="bet-option" onclick="selectBet(1000)">1000</div>
        </div>
        <br>
        <button class="btn" onclick="createDuelLink()">СОЗДАТЬ ДУЭЛЬ</button>
        <button class="btn btn-secondary" onclick="document.getElementById('bet-modal').style.display='none'">ОТМЕНА</button>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div id="game-over-modal" class="modal">
    <div class="modal-content">
        <h2 style="color: red;">GAME OVER</h2>
        <h3 id="final-score">Score: 0</h3>
        <p id="duel-result-msg" style="font-size: 0.8rem; color: #aaa;"></p>
        <button class="btn" onclick="backToMenu()">В МЕНЮ</button>
    </div>
</div>

<div class="nav-tabs">
    <div class="tab active" onclick="showScreen('menu'); updateTab(this)">АРЕНА</div>
    <div class="tab" onclick="showScreen('profile'); updateTab(this)">ПРОФИЛЬ</div>
</div>

<script>
    // --- CONFIG ---
    const API_URL = "https://tg-game-arena.onrender.com"; 
    const tg = window.Telegram.WebApp;
    tg.ready(); tg.expand();
    tg.setHeaderColor('#0d0d15'); tg.setBackgroundColor('#0d0d15');

    let currentUser = null;
    let currentLobby = null;
    let selectedBet = 10;
    let gameLoopId = null;
    let currentGame = '';
    let score = 0;

    // --- INITIALIZATION ---
    async function init() {
        try {
            // 1. Auth
            const res = await fetch(`${API_URL}/api/user-data`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ initData: tg.initData })
            });
            currentUser = await res.json();
            updateProfileUI();

            // 2. Check Launch Params (Duel Join)
            const startParam = tg.initDataUnsafe.start_param;
            if (startParam) {
                const joinRes = await fetch(`${API_URL}/api/join-lobby`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ telegramId: currentUser.telegramId, startParam })
                });
                const joinData = await joinRes.json();
                
                if (joinData.error) {
                    tg.showAlert(joinData.error);
                } else if (joinData.mode === 'duel') {
                    currentLobby = joinData.lobby;
                    document.getElementById('duel-status').innerText = `ДУЭЛЬ НА ${currentLobby.betAmount} STARS`;
                    
                    // Сразу предлагаем выбрать игру для дуэли (упрощение: оба играют в то, что выберут сами, но лучше синхронизировать)
                    // Для простоты: дуэль всегда в Тетрис
                    startGame('tetris', true); 
                }
            }
        } catch (e) { console.error(e); }
    }
    init();

    // --- UI LOGIC ---
    function showScreen(name) {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById(`screen-${name}`).classList.add('active');
        document.querySelector('.nav-tabs').style.display = (name === 'game') ? 'none' : 'flex';
    }
    function updateTab(el) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        el.classList.add('active');
    }
    function updateProfileUI() {
        if(!currentUser) return;
        document.getElementById('p-name').innerText = currentUser.username || "Player";
        document.getElementById('p-balance').innerText = currentUser.balance;
        document.getElementById('p-snake').innerText = currentUser.highScores.snake;
        document.getElementById('p-tetris').innerText = currentUser.highScores.tetris;
    }
    function backToMenu() {
        document.getElementById('game-over-modal').style.display = 'none';
        showScreen('menu');
        location.reload(); // Перезагрузка для сброса стейта лобби
    }

    // --- PAYMENTS & BETS ---
    function openBetModal() {
        document.getElementById('bet-modal').style.display = 'flex';
    }
    function selectBet(amount) {
        selectedBet = amount;
        document.querySelectorAll('.bet-option').forEach(el => el.classList.remove('selected'));
        event.target.classList.add('selected');
    }
    async function createDuelLink() {
        if (currentUser.balance < selectedBet) {
            tg.showAlert("Недостаточно средств!"); return;
        }
        try {
            const res = await fetch(`${API_URL}/api/create-lobby`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, betAmount: selectedBet })
            });
            const data = await res.json();
            if (data.success) {
                const link = `https://t.me/share/url?url=https://t.me/RetroBattleBot/app?startapp=${data.lobbyId}&text=Играем в Тетрис на ${selectedBet} Stars!`;
                tg.openTelegramLink(link);
                currentUser.balance = data.newBalance;
                updateProfileUI();
            } else {
                tg.showAlert(data.error);
            }
        } catch (e) { tg.showAlert("Ошибка сети"); }
    }
    async function buyStars() {
        const amt = document.getElementById('deposit-amount').value;
        const res = await fetch(`${API_URL}/api/create-invoice`, {
            method: 'POST', headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ amount: parseInt(amt) })
        });
        const data = await res.json();
        if (data.invoiceLink) tg.openInvoice(data.invoiceLink);
    }
    async function withdrawFunds() {
        const amt = prompt("Сколько вывести?", "100");
        if (!amt) return;
        const res = await fetch(`${API_URL}/api/withdraw`, {
            method: 'POST', headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ telegramId: currentUser.telegramId, amount: parseInt(amt) })
        });
        const data = await res.json();
        if (data.success) {
            currentUser.balance = data.newBalance;
            updateProfileUI();
            tg.showAlert("Заявка создана!");
        } else {
            tg.showAlert(data.error);
        }
    }

    // --- GAME ENGINE SETUP ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 240; canvas.height = 400; // Retro resolution

    function startGame(game, isDuel = false) {
        currentGame = game;
        showScreen('game');
        document.getElementById('game-over-modal').style.display = 'none';
        document.getElementById('game-info').innerText = isDuel ? "ДУЭЛЬ" : "Тренировка";
        
        if (game === 'tetris') startTetris();
        if (game === 'snake') startSnake();
    }

    function handleInput(dir, e) {
        if(e) e.preventDefault();
        const map = { 'left': 'ArrowLeft', 'up': 'ArrowUp', 'right': 'ArrowRight', 'down': 'ArrowDown' };
        document.dispatchEvent(new KeyboardEvent('keydown', {'key': map[dir]}));
    }

    async function gameOverAction(finalScore) {
        cancelAnimationFrame(gameLoopId);
        clearInterval(gameLoopId);
        
        document.getElementById('final-score').innerText = `Score: ${finalScore}`;
        document.getElementById('duel-result-msg').innerText = "Отправка результата...";
        document.getElementById('game-over-modal').style.display = 'flex';

        // Submit Score
        await fetch(`${API_URL}/api/submit-score`, {
            method: 'POST', headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                telegramId: currentUser.telegramId,
                game: currentGame,
                score: finalScore,
                lobbyId: currentLobby ? currentLobby.lobbyId : null
            })
        });
        
        if (currentLobby) {
            document.getElementById('duel-result-msg').innerText = "Результат записан. Победитель получит награду автоматически.";
        } else {
            document.getElementById('duel-result-msg').innerText = "Тренировка завершена.";
        }
    }

    // ==========================================
    // TETRIS ENGINE (IMPROVED)
    // ==========================================
    const ROW = 20; const COL = 12; const SQ = 20;
    const VACANT = "BLACK";
    let board = [];
    let p;

    const PIECES = [
        [Z, "red"], [S, "green"], [T, "#ff0055"], [O, "yellow"], [L, "purple"], [I, "cyan"], [J, "orange"]
    ];
    // Shapes definitions (0/1 matrix)
    const I = [[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]], [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]];
    const J = [[[1,0,0],[1,1,1],[0,0,0]], [[0,1,1],[0,1,0],[0,1,0]], [[0,0,0],[1,1,1],[0,0,1]], [[0,1,0],[0,1,0],[1,1,0]]];
    const L = [[[0,0,1],[1,1,1],[0,0,0]], [[0,1,0],[0,1,0],[0,1,1]], [[0,0,0],[1,1,1],[1,0,0]], [[1,1,0],[0,1,0],[0,1,0]]];
    const O = [[[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]], [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]], [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]], [[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0]]];
    const S = [[[0,1,1],[1,1,0],[0,0,0]], [[0,1,0],[0,1,1],[0,0,1]], [[0,0,0],[0,1,1],[1,1,0]], [[1,0,0],[1,1,0],[0,1,0]]];
    const T = [[[0,1,0],[1,1,1],[0,0,0]], [[0,1,0],[0,1,1],[0,1,0]], [[0,0,0],[1,1,1],[0,1,0]], [[0,1,0],[1,1,0],[0,1,0]]];
    const Z = [[[1,1,0],[0,1,1],[0,0,0]], [[0,0,1],[0,1,1],[0,1,0]], [[0,0,0],[1,1,0],[0,1,1]], [[0,1,0],[1,1,0],[1,0,0]]];
    
    // Fix PIECES mapping after defining shapes
    PIECES[0][0]=Z; PIECES[1][0]=S; PIECES[2][0]=T; PIECES[3][0]=O; PIECES[4][0]=L; PIECES[5][0]=I; PIECES[6][0]=J;

    function startTetris() {
        score = 0; document.getElementById('score-board').innerText = "SCORE: 0";
        board = [];
        for(let r=0; r<ROW; r++){
            board[r] = [];
            for(let c=0; c<COL; c++) board[r][c] = VACANT;
        }
        p = randomPiece();
        let dropStart = Date.now();
        
        function drawSquare(x,y,color){
            ctx.fillStyle = color; ctx.fillRect(x*SQ,y*SQ,SQ,SQ);
            ctx.strokeStyle = "#111"; ctx.strokeRect(x*SQ,y*SQ,SQ,SQ);
        }
        function drawBoard(){
            for(let r=0; r<ROW; r++)
                for(let c=0; c<COL; c++) drawSquare(c,r,board[r][c]);
        }
        function drawPiece(){
            let current = p.tetromino[p.tetrominoN];
            for(let r=0; r<current.length; r++){
                for(let c=0; c<current.length; c++){
                    if(current[r][c]) drawSquare(p.x+c, p.y+r, p.color);
                }
            }
        }
        
        // Loop
        function tick() {
            let now = Date.now();
            let delta = now - dropStart;
            if(delta > 500){
                moveDown(); dropStart = Date.now();
            }
            drawBoard();
            drawPiece();
            gameLoopId = requestAnimationFrame(tick);
        }
        if (gameLoopId) cancelAnimationFrame(gameLoopId);
        tick();

        // Control
        document.onkeydown = function(e){
            if(currentGame !== 'tetris') return;
            if(e.key == "ArrowLeft") { if(!collision(-1,0,p.tetromino[p.tetrominoN])) p.x--; }
            else if(e.key == "ArrowRight") { if(!collision(1,0,p.tetromino[p.tetrominoN])) p.x++; }
            else if(e.key == "ArrowDown") { moveDown(); }
            else if(e.key == "ArrowUp") {
                let nextPattern = p.tetromino[(p.tetrominoN + 1) % p.tetromino.length];
                let kick = 0;
                if(collision(0,0,nextPattern)){
                    if(p.x > COL/2) kick = -1; else kick = 1;
                }
                if(!collision(kick,0,nextPattern)){
                    p.x += kick;
                    p.tetrominoN = (p.tetrominoN + 1) % p.tetromino.length;
                }
            }
        }
    }

    function moveDown(){
        if(!collision(0,1,p.tetromino[p.tetrominoN])){
            p.y++;
        } else {
            lock();
            p = randomPiece();
            if(collision(0,0,p.tetromino[p.tetrominoN])) gameOverAction(score); // Game Over
        }
    }

    function collision(x,y,piece){
        for(let r=0; r<piece.length; r++){
            for(let c=0; c<piece.length; c++){
                if(!piece[r][c]) continue;
                let newX = p.x + c + x;
                let newY = p.y + r + y;
                if(newX < 0 || newX >= COL || newY >= ROW) return true;
                if(newY < 0) continue;
                if(board[newY][newX] != VACANT) return true;
            }
        }
        return false;
    }

    function lock(){
        let current = p.tetromino[p.tetrominoN];
        for(let r=0; r<current.length; r++){
            for(let c=0; c<current.length; c++){
                if(!current[r][c]) continue;
                if(p.y + r < 0) { gameOverAction(score); return; }
                board[p.y+r][p.x+c] = p.color;
            }
        }
        // Remove lines
        for(let r=0; r<ROW; r++){
            let isFull = true;
            for(let c=0; c<COL; c++) isFull = isFull && (board[r][c] != VACANT);
            if(isFull){
                for(let y=r; y>1; y--)
                    for(let c=0; c<COL; c++) board[y][c] = board[y-1][c];
                for(let c=0; c<COL; c++) board[0][c] = VACANT;
                score += 100;
                document.getElementById('score-board').innerText = "SCORE: " + score;
            }
        }
    }

    function randomPiece(){
        let r = Math.floor(Math.random() * PIECES.length);
        return {
            tetromino: PIECES[r][0],
            color: PIECES[r][1],
            tetrominoN: 0,
            x: 3, y: -2
        }
    }

    // ==========================================
    // SNAKE (KEPT AS IS)
    // ==========================================
    function startSnake() {
        score = 0; document.getElementById('score-board').innerText = "SCORE: 0";
        let snake = [{x:10, y:10}];
        let food = {x:15, y:15};
        let dx=0, dy=0;
        
        document.onkeydown = function(e){
            if(currentGame !== 'snake') return;
            if(e.key === 'ArrowUp' && dy !== 1) { dx=0; dy=-1; }
            if(e.key === 'ArrowDown' && dy !== -1) { dx=0; dy=1; }
            if(e.key === 'ArrowLeft' && dx !== 1) { dx=-1; dy=0; }
            if(e.key === 'ArrowRight' && dx !== -1) { dx=1; dy=0; }
        }

        function loop(){
            let head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            // Wall Check
            if(head.x < 0 || head.x >= 12 || head.y < 0 || head.y >= 20 || 
               snake.some(s => s.x === head.x && s.y === head.y && dx|dy)) { // dx|dy check ensures no instant death on start
                 if(dx!==0 || dy!==0) { gameOverAction(score); return; }
                 head = snake[0]; // Stay still at start
            }

            if(dx!==0 || dy!==0) snake.unshift(head);
            
            if(head.x === food.x && head.y === food.y){
                score+=10; document.getElementById('score-board').innerText = "SCORE: " + score;
                food = {x: Math.floor(Math.random()*12), y: Math.floor(Math.random()*20)};
            } else if(dx!==0 || dy!==0) {
                snake.pop();
            }

            // Draw
            ctx.fillStyle = "black"; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = "red"; ctx.fillRect(food.x*20, food.y*20, 18, 18);
            ctx.fillStyle = "#00f0ff";
            snake.forEach(s => ctx.fillRect(s.x*20, s.y*20, 18, 18));
        }
        if (gameLoopId) clearInterval(gameLoopId);
        gameLoopId = setInterval(loop, 150);
    }
</script>
</body>
</html>

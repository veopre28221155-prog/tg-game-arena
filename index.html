<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Arena</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Pixel Font -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Telegram Theme Integration */
            --tg-bg: var(--tg-theme-bg-color, #1c1c1e);
            --tg-text: var(--tg-theme-text-color, #ffffff);
            --tg-btn: var(--tg-theme-button-color, #2481cc);
            --tg-btn-text: var(--tg-theme-button-text-color, #ffffff);
            --tg-sec-bg: var(--tg-theme-secondary-bg-color, #2c2c2e);
            
            /* Retro Accents */
            --accent-neon: #00f0ff;
            --accent-pink: #ff0055;
            --font-retro: 'Press Start 2P', cursive;
        }

        body {
            margin: 0;
            background-color: var(--tg-bg);
            color: var(--tg-text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* LAYOUT */
        .screen {
            display: none;
            flex: 1;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            padding: 20px;
            padding-bottom: 80px; /* Space for tabs */
        }
        .screen.active { display: flex; }

        /* TYPOGRAPHY */
        h1, h2 { font-family: var(--font-retro); color: var(--tg-text); text-transform: uppercase; margin-bottom: 20px; text-shadow: 2px 2px 0px rgba(0,0,0,0.5); }
        h1 { font-size: 1.5rem; color: var(--accent-neon); }
        
        /* COMPONENTS */
        .card {
            background-color: var(--tg-sec-bg);
            border-radius: 12px;
            padding: 16px;
            width: 100%;
            max-width: 350px;
            box-sizing: border-box;
            margin-bottom: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .btn {
            background-color: var(--tg-btn);
            color: var(--tg-btn-text);
            border: none;
            border-radius: 8px;
            padding: 14px;
            width: 100%;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-family: var(--font-retro);
            font-size: 0.8rem;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); opacity: 0.9; }
        .btn-outline { background: transparent; border: 2px solid var(--tg-btn); color: var(--tg-btn); }
        .btn-danger { background: var(--accent-pink); color: white; }

        /* INPUTS */
        select, input {
            background: var(--tg-bg);
            color: var(--tg-text);
            border: 1px solid var(--tg-btn);
            padding: 10px;
            border-radius: 8px;
            width: 100%;
            margin-bottom: 10px;
            font-family: inherit;
        }

        /* GAME CANVAS */
        canvas {
            border: 4px solid var(--tg-text);
            border-radius: 4px;
            background: #000;
            image-rendering: pixelated;
            max-height: 55vh;
            width: auto;
        }

        /* CONTROLS */
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
            width: 200px;
        }
        .d-pad {
            background: rgba(255,255,255,0.1);
            border: 2px solid var(--tg-text);
            border-radius: 12px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        .d-pad:active { background: var(--accent-neon); color: #000; }

        /* STATS ROW */
        .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.1); padding: 8px 0; font-size: 0.9rem; }

        /* TABS */
        .tabs {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: var(--tg-sec-bg);
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-top: 1px solid rgba(0,0,0,0.2);
            z-index: 100;
        }
        .tab {
            display: flex;
            flex-direction: column;
            align-items: center;
            color: var(--tg-text);
            opacity: 0.5;
            font-size: 0.7rem;
            cursor: pointer;
        }
        .tab.active { opacity: 1; color: var(--accent-neon); }
        .tab-icon { font-size: 1.2rem; margin-bottom: 4px; }

        /* ANIMATION */
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }
        .searching-anim { animation: pulse 1.5s infinite; color: var(--accent-neon); margin: 20px 0; font-family: var(--font-retro); }
    </style>
</head>
<body>

<div id="app">
    <!-- TAB 1: PLAY -->
    <div id="s-play" class="screen active">
        <h1>RETRO ARENA</h1>
        
        <div class="card">
            <h2>Solo Training</h2>
            <button class="btn btn-outline" onclick="launchGame('snake', false)">üêç Snake</button>
            <button class="btn btn-outline" onclick="launchGame('tetris', false)">üß± Tetris</button>
        </div>

        <div class="card" style="border: 2px solid var(--accent-neon);">
            <h2>Ranked Match</h2>
            <p style="font-size: 0.8rem; opacity: 0.7; text-align: center; margin-bottom: 10px;">Find random opponent</p>
            
            <label>Game:</label>
            <select id="search-game">
                <option value="snake">Snake</option>
                <option value="tetris">Tetris</option>
            </select>

            <label>Bet (Stars):</label>
            <select id="search-bet">
                <option value="10">10 ‚≠êÔ∏è</option>
                <option value="50">50 ‚≠êÔ∏è</option>
                <option value="100">100 ‚≠êÔ∏è</option>
                <option value="500">500 ‚≠êÔ∏è</option>
            </select>

            <button class="btn" onclick="startMatchmaking()">üîç FIND MATCH</button>
        </div>
        
        <div class="card">
            <h2>Friend Match</h2>
            <button class="btn btn-outline" onclick="createFriendLobby()">Create Link</button>
        </div>
    </div>

    <!-- SEARCHING SCREEN -->
    <div id="s-search" class="screen" style="justify-content: center;">
        <h1>SEARCHING...</h1>
        <div class="searching-anim">LOOKING FOR OPPONENT</div>
        <p style="text-align: center; font-size: 0.9rem; opacity: 0.8;">Please wait while we match you with a player betting same amount.</p>
        <button class="btn btn-danger" onclick="cancelMatchmaking()" style="margin-top: 30px;">CANCEL SEARCH</button>
    </div>

    <!-- TAB 2: PROFILE -->
    <div id="s-profile" class="screen">
        <h1>PROFILE</h1>
        
        <div class="card" style="text-align: center;">
            <div style="font-size: 3rem; font-family: var(--font-retro); color: gold;">
                <span id="p-bal">0</span>
            </div>
            <div style="opacity: 0.7;">STARS BALANCE</div>
        </div>

        <div class="card">
            <h2>Stats</h2>
            <div class="stat-row"><span>ID:</span> <span id="p-id">...</span></div>
            <div class="stat-row"><span>Best Snake:</span> <span id="p-snake">0</span></div>
            <div class="stat-row"><span>Best Tetris:</span> <span id="p-tetris">0</span></div>
        </div>

        <div class="card">
            <h2>Deposit</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <button class="btn btn-outline" onclick="deposit(10)">+10</button>
                <button class="btn btn-outline" onclick="deposit(50)">+50</button>
                <button class="btn btn-outline" onclick="deposit(100)">+100</button>
                <button class="btn btn-outline" onclick="deposit(500)">+500</button>
            </div>
        </div>

        <button class="btn btn-danger" onclick="withdraw()">WITHDRAW FUNDS</button>
    </div>

    <!-- GAME SCREEN -->
    <div id="s-game" class="screen" style="justify-content: start; padding-top: 10px;">
        <div style="display: flex; justify-content: space-between; width: 100%; max-width: 400px; margin-bottom: 10px;">
            <button class="btn btn-danger" style="width: auto; padding: 5px 15px;" onclick="quitGame()">EXIT</button>
            <div style="font-family: var(--font-retro); color: gold; font-size: 1.2rem;">
                SCORE: <span id="g-score">0</span>
            </div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        
        <div class="controls">
            <div class="d-pad" ontouchstart="input('left')" onmousedown="input('left')">‚Üê</div>
            <div class="d-pad" ontouchstart="input('up')" onmousedown="input('up')">‚Üª</div>
            <div class="d-pad" ontouchstart="input('right')" onmousedown="input('right')">‚Üí</div>
            <div class="d-pad" style="grid-column: 2;" ontouchstart="input('down')" onmousedown="input('down')">‚Üì</div>
        </div>
    </div>
</div>

<!-- BOTTOM TABS -->
<div class="tabs">
    <div class="tab active" onclick="nav('play', this)">
        <div class="tab-icon">üéÆ</div>
        <div>PLAY</div>
    </div>
    <div class="tab" onclick="nav('profile', this)">
        <div class="tab-icon">üë§</div>
        <div>PROFILE</div>
    </div>
</div>

<!-- MODAL: GAME OVER -->
<div id="modal-over" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:200; align-items:center; justify-content:center; flex-direction:column;">
    <h1 style="color:red; font-size:3rem;">GAME OVER</h1>
    <h2 id="end-score" style="color:white;">Score: 0</h2>
    <p id="end-msg" style="color:gold; text-align:center; padding:20px;"></p>
    <button class="btn" style="width:200px;" onclick="location.reload()">MAIN MENU</button>
</div>

<script>
    const API = "https://tg-game-arena.onrender.com";
    const tg = window.Telegram.WebApp;
    tg.ready(); tg.expand();
    
    // Theme setup
    document.documentElement.style.setProperty('--tg-bg', tg.themeParams.bg_color || '#1c1c1e');
    document.documentElement.style.setProperty('--tg-text', tg.themeParams.text_color || '#ffffff');
    document.documentElement.style.setProperty('--tg-btn', tg.themeParams.button_color || '#2481cc');
    document.documentElement.style.setProperty('--tg-btn-text', tg.themeParams.button_text_color || '#ffffff');

    let user = null;
    let lobby = null;
    let pollInterval = null;
    
    // Game Vars
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 240; canvas.height = 400;
    const BLK = 20; 
    let loop = null, gameType = '', score = 0;

    // --- INIT ---
    async function init() {
        try {
            // Login
            const r = await fetch(`${API}/api/user-data`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ initData: tg.initData })
            });
            user = await r.json();
            updateUI();

            // Check Start Param
            const startParam = tg.initDataUnsafe.start_param;
            if (startParam) {
                const j = await fetch(`${API}/api/join-lobby`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ telegramId: user.telegramId, startParam })
                });
                const d = await j.json();
                if (d.mode === 'duel') {
                    lobby = d.lobby;
                    launchGame(lobby.gameType, true);
                } else if(d.error) {
                    tg.showAlert(d.error);
                }
            }
        } catch (e) { console.error(e); }
    }
    init();

    // --- NAVIGATION ---
    function nav(id, el) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(`s-${id}`).classList.add('active');
        if(el) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            el.classList.add('active');
        }
    }

    function updateUI() {
        if(!user) return;
        document.getElementById('p-bal').innerText = user.balance;
        document.getElementById('p-id').innerText = user.telegramId;
        document.getElementById('p-snake').innerText = user.highScores.snake;
        document.getElementById('p-tetris').innerText = user.highScores.tetris;
    }

    // --- MATCHMAKING ---
    async function startMatchmaking() {
        const game = document.getElementById('search-game').value;
        const bet = parseInt(document.getElementById('search-bet').value);
        
        if (user.balance < bet) return tg.showAlert("Insufficient Stars!");

        nav('search');

        try {
            const r = await fetch(`${API}/api/search-match`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: user.telegramId, gameType: game, betAmount: bet })
            });
            const d = await r.json();
            
            if (d.error) {
                tg.showAlert(d.error);
                nav('play');
            } else if (d.status === 'match_found') {
                // Instant match
                lobby = { lobbyId: d.lobbyId, betAmount: bet }; // Minimal info needed
                user.balance = d.newBalance;
                launchGame(game, true);
            } else if (d.status === 'waiting') {
                user.balance = d.newBalance; // Balance deducted
                // Start Polling
                pollInterval = setInterval(checkMatchStatus, 2000);
            }
        } catch(e) { tg.showAlert("Error connecting"); nav('play'); }
    }

    async function checkMatchStatus() {
        try {
            const r = await fetch(`${API}/api/check-match-status`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: user.telegramId })
            });
            const d = await r.json();
            
            if (d.status === 'match_found') {
                clearInterval(pollInterval);
                lobby = d.lobby;
                launchGame(lobby.gameType, true);
            }
        } catch(e) { console.error(e); }
    }

    async function cancelMatchmaking() {
        clearInterval(pollInterval);
        try {
            const r = await fetch(`${API}/api/cancel-match`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: user.telegramId })
            });
            const d = await r.json();
            if(d.success) {
                user.balance = d.newBalance;
                tg.showAlert("Search cancelled. Stars refunded.");
                nav('play');
            }
        } catch(e) { tg.showAlert("Error"); nav('play'); }
    }

    async function createFriendLobby() {
        const bet = prompt("Enter bet amount (min 10):", "10");
        if(!bet || bet < 10) return;
        const game = prompt("Enter game (snake/tetris):", "tetris");
        
        // Use backend to create specific link (Reusing create-lobby-friend logic implies adding that endpoint or using generic create-lobby logic adapted)
        // For simplicity, showing alert logic, need backend endpoint for this or reuse search-match logic creatively.
        // Let's assume standard friend flow exists or use search logic.
        tg.showAlert("Use matchmaking for now, friend links coming in v2!");
    }

    // --- PAYMENTS ---
    async function deposit(amt) {
        const r = await fetch(`${API}/api/create-invoice`, {
             method: 'POST', headers: {'Content-Type': 'application/json'},
             body: JSON.stringify({ amount: amt })
        });
        const d = await r.json();
        if(d.invoiceLink) tg.openInvoice(d.invoiceLink, (s)=>{ if(s==='paid'){ user.balance+=amt; updateUI(); }});
    }

    async function withdraw() {
        if(user.balance <= 0) return tg.showAlert("Empty balance");
        if(!confirm("Withdraw all to source?")) return;
        await fetch(`${API}/api/withdraw`, {
             method: 'POST', headers: {'Content-Type': 'application/json'},
             body: JSON.stringify({ telegramId: user.telegramId, amount: user.balance })
        });
        user.balance=0; updateUI(); tg.showAlert("Request sent!");
    }

    // --- GAMES ---
    function launchGame(type, isRanked) {
        clearInterval(pollInterval);
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.querySelector('.tabs').style.display = 'none';
        document.getElementById('s-game').classList.add('active');
        
        gameType = type;
        score = 0;
        document.getElementById('g-score').innerText = 0;
        
        if (type === 'snake') runSnake();
        if (type === 'tetris') runTetris();
    }

    function quitGame() {
        if(confirm("Quit game?")) {
            if(loop) cancelAnimationFrame(loop);
            clearTimeout(loop);
            location.reload();
        }
    }

    async function gameOver() {
        if(loop) cancelAnimationFrame(loop);
        clearTimeout(loop);
        
        document.getElementById('modal-over').style.display = 'flex';
        document.getElementById('end-score').innerText = "Score: " + score;
        document.getElementById('end-msg').innerText = lobby ? "Sending Result..." : "Practice Finished";

        await fetch(`${API}/api/submit-score`, {
            method: 'POST', headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ telegramId: user.telegramId, game: gameType, score, lobbyId: lobby?.lobbyId })
        });
        
        if(lobby) document.getElementById('end-msg').innerText = "Result saved! Winner gets prize.";
    }

    function input(k) {
        const e = new KeyboardEvent('keydown', { key: k==='left'?'ArrowLeft': k==='right'?'ArrowRight': k==='up'?'ArrowUp':'ArrowDown' });
        document.dispatchEvent(e);
    }

    // --- SNAKE ENGINE ---
    function runSnake() {
        let s=[{x:5,y:10}], f={x:2,y:2}, d={x:0,y:0};
        const cols=12, rows=20;
        
        function update() {
            let h={x:s[0].x+d.x, y:s[0].y+d.y};
            
            // Wall
            if(h.x<0||h.x>=cols||h.y<0||h.y>=rows||(d.x|d.y && s.some(p=>p.x===h.x&&p.y===h.y))) return gameOver();
            
            if(d.x|d.y) s.unshift(h);
            
            // Food
            if(h.x===f.x && h.y===f.y) {
                score+=10; document.getElementById('g-score').innerText=score;
                f={x:Math.floor(Math.random()*cols), y:Math.floor(Math.random()*rows)};
            } else if(d.x|d.y) {
                s.pop();
            }

            // Draw
            ctx.fillStyle='#000'; ctx.fillRect(0,0,240,400);
            // Grid (Optional retro feel)
            ctx.strokeStyle='#111'; ctx.beginPath();
            for(let i=0;i<cols;i++) { ctx.moveTo(i*BLK,0); ctx.lineTo(i*BLK,400); }
            ctx.stroke();

            ctx.fillStyle='#ff0055'; ctx.fillRect(f.x*BLK, f.y*BLK, BLK-2, BLK-2);
            ctx.fillStyle='#00f0ff'; s.forEach(p => ctx.fillRect(p.x*BLK, p.y*BLK, BLK-2, BLK-2));
            
            loop = setTimeout(() => requestAnimationFrame(update), 150);
        }

        document.onkeydown = e => {
            if(gameType!=='snake') return;
            if(e.key==='ArrowLeft'&&d.x!==1) d={x:-1,y:0};
            if(e.key==='ArrowRight'&&d.x!==-1) d={x:1,y:0};
            if(e.key==='ArrowUp'&&d.y!==1) d={x:0,y:-1};
            if(e.key==='ArrowDown'&&d.y!==-1) d={x:0,y:1};
            if(!d.x && !d.y) d={x:0,y:1}; // Start on any key
        };
        update();
    }

    // --- TETRIS ENGINE (FIXED) ---
    function runTetris() {
        const R=20, C=12;
        let board = Array.from({length:R}, () => Array(C).fill(0));
        const SHAPES = [
            [[1,1,1,1]], // I
            [[1,1,1],[0,1,0]], // T
            [[1,1],[1,1]], // O
            [[1,1,0],[0,1,1]], // Z
            [[0,1,1],[1,1,0]], // S
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]]  // J
        ];
        const COLORS = [null, '#00f0ff', '#bc13fe', '#ffff00', '#ff0055', '#00ff00', '#ff8800', '#0000ff'];

        let p = randomPiece();
        let dropCounter = 0;
        let dropInterval = 1000; // 1 sec drop
        let lastTime = 0;

        function randomPiece() {
            let id = Math.floor(Math.random() * SHAPES.length);
            return { m: SHAPES[id], c: id+1, x: 4, y: 0 };
        }

        function draw() {
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,240,400);
            
            // Draw Board
            for(let y=0; y<R; y++) {
                for(let x=0; x<C; x++) {
                    if(board[y][x]) {
                        ctx.fillStyle = COLORS[board[y][x]];
                        ctx.fillRect(x*BLK, y*BLK, BLK-1, BLK-1);
                    }
                }
            }
            // Draw Piece
            p.m.forEach((row, y) => {
                row.forEach((val, x) => {
                    if(val) {
                        ctx.fillStyle = COLORS[p.c];
                        ctx.fillRect((p.x+x)*BLK, (p.y+y)*BLK, BLK-1, BLK-1);
                    }
                });
            });
        }

        function collide(arena, player) {
            const m = player.m; const o = {x:player.x, y:player.y};
            for(let y=0; y<m.length; ++y) {
                for(let x=0; x<m[y].length; ++x) {
                    if(m[y][x] !== 0 && (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0) return true;
                }
            }
            return false;
        }

        function rotate(matrix) {
            for(let y=0; y<matrix.length; ++y) {
                for(let x=0; x<y; ++x) {
                    [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
            }
            matrix.forEach(row => row.reverse());
        }

        function playerRotate() {
            const pos = p.x;
            let offset = 1;
            rotate(p.m);
            while(collide(board, p)) {
                p.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if(offset > p.m[0].length) {
                    rotate(p.m); rotate(p.m); rotate(p.m); // Rotate back
                    p.x = pos;
                    return;
                }
            }
        }

        function arenaSweep() {
            let rowCount = 0;
            outer: for(let y=R-1; y>0; --y) {
                for(let x=0; x<C; ++x) {
                    if(board[y][x] === 0) continue outer;
                }
                const row = board.splice(y, 1)[0].fill(0);
                board.unshift(row);
                ++y;
                rowCount++;
            }
            if(rowCount > 0) {
                score += rowCount * 100;
                document.getElementById('g-score').innerText = score;
                dropInterval = Math.max(100, 1000 - (score/5)); // Speed up
            }
        }

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if(dropCounter > dropInterval) {
                p.y++;
                if(collide(board, p)) {
                    p.y--;
                    // Merge
                    p.m.forEach((row, y) => {
                        row.forEach((val, x) => {
                            if(val) board[y+p.y][x+p.x] = p.c;
                        });
                    });
                    arenaSweep();
                    p = randomPiece();
                    if(collide(board, p)) {
                        gameOver(); // Game Over
                        return;
                    }
                }
                dropCounter = 0;
            }
            draw();
            loop = requestAnimationFrame(update);
        }

        document.onkeydown = e => {
            if(gameType!=='tetris') return;
            if(e.key==='ArrowLeft') { p.x--; if(collide(board, p)) p.x++; }
            if(e.key==='ArrowRight') { p.x++; if(collide(board, p)) p.x--; }
            if(e.key==='ArrowDown') { p.y++; if(collide(board, p)) p.y--; }
            if(e.key==='ArrowUp') playerRotate();
        };

        update();
    }
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Battle Arena</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #0d0d15;
            --primary-blue: #00f0ff;
            --secondary-purple: #bc13fe;
            --text-color: #e0e0e0;
            --panel-bg: rgba(20, 20, 35, 0.98);
        }

        body {
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            display: flex; flex-direction: column; height: 100vh;
            user-select: none; -webkit-user-select: none;
        }

        /* --- UI --- */
        .screen {
            display: none; flex: 1; flex-direction: column;
            align-items: center; justify-content: center;
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
        }
        .screen.active { display: flex; }

        .neon-text {
            text-shadow: 0 0 10px var(--primary-blue);
            color: #fff; font-size: 2rem; margin-bottom: 20px; font-weight: bold;
            text-align: center;
        }

        .btn {
            background: linear-gradient(45deg, #1a1a2e, #16213e);
            border: 2px solid var(--primary-blue);
            color: var(--primary-blue);
            padding: 12px 20px; margin: 8px; font-size: 1.1rem;
            cursor: pointer; width: 80%; max-width: 300px;
            text-transform: uppercase; font-weight: bold;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.2);
        }
        .btn:active { transform: scale(0.95); background: var(--primary-blue); color: #000; }

        .btn-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; width: 90%; max-width: 320px;
        }
        .btn-small {
            font-size: 0.9rem; padding: 8px; margin: 0; width: 100%;
        }

        .profile-card {
            background: var(--panel-bg); border: 1px solid var(--secondary-purple);
            padding: 20px; border-radius: 10px; width: 85%; margin-bottom: 20px;
        }
        .stat-row { display: flex; justify-content: space-between; margin: 8px 0; border-bottom: 1px dashed #444; }

        /* --- CANVAS --- */
        canvas {
            border: 2px solid var(--primary-blue); background-color: #000;
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.2);
            image-rendering: pixelated;
        }
        .game-header { width: 90%; display: flex; justify-content: space-between; margin-bottom: 10px; }

        /* --- CONTROLS --- */
        .controls {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;
            margin-top: 15px; width: 240px;
        }
        .ctrl-btn {
            background: rgba(255, 255, 255, 0.1); border: 1px solid var(--primary-blue);
            height: 60px; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; font-size: 24px; color: white;
            touch-action: manipulation;
        }
        .ctrl-btn:active { background: var(--primary-blue); }

        /* --- MODAL --- */
        .modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .modal-content {
            background: var(--panel-bg); padding: 20px; border: 2px solid var(--primary-blue);
            text-align: center; width: 80%;
        }

        /* --- TABS --- */
        .nav-tabs {
            position: fixed; bottom: 0; width: 100%; height: 60px;
            display: flex; background: var(--panel-bg); border-top: 2px solid var(--secondary-purple);
            z-index: 50;
        }
        .tab { flex: 1; display: flex; align-items: center; justify-content: center; color: #888; }
        .tab.active { color: var(--primary-blue); }
    </style>
</head>
<body>

<div id="app">
    <!-- MENU -->
    <div id="screen-menu" class="screen active">
        <h1 class="neon-text">RETRO ARENA</h1>
        <div id="duel-info" style="color: #ff0055; margin-bottom: 15px; font-weight: bold;"></div>
        
        <button class="btn" onclick="launchGame('snake', false)">üêç SNAKE</button>
        <button class="btn" onclick="launchGame('tetris', false)">üß± TETRIS</button>
        <button class="btn" style="border-color: var(--secondary-purple); color: var(--secondary-purple);" onclick="openBetModal()">‚öîÔ∏è –î–£–≠–õ–¨ (PvP)</button>
    </div>

    <!-- PROFILE -->
    <div id="screen-profile" class="screen">
        <h2 class="neon-text">–ü–†–û–§–ò–õ–¨</h2>
        <div class="profile-card">
            <div class="stat-row"><span>ID:</span> <span id="p-id">...</span></div>
            <div class="stat-row"><span>–ë–∞–ª–∞–Ω—Å:</span> <span id="p-balance" style="color: gold;">0 ‚òÖ</span></div>
            <div class="stat-row"><span>Snake Record:</span> <span id="p-snake">0</span></div>
            <div class="stat-row"><span>Tetris Record:</span> <span id="p-tetris">0</span></div>
        </div>
        
        <p style="text-align: center; margin-bottom: 5px;">–ü–æ–ø–æ–ª–Ω–∏—Ç—å Stars:</p>
        <div class="btn-grid">
            <button class="btn btn-small" onclick="buyStars(10)">10</button>
            <button class="btn btn-small" onclick="buyStars(50)">50</button>
            <button class="btn btn-small" onclick="buyStars(100)">100</button>
            <button class="btn btn-small" onclick="buyStars(500)">500</button>
            <button class="btn btn-small" onclick="buyStars(1000)">1000</button>
        </div>

        <button class="btn" style="border-color: red; color: red; margin-top: 20px;" onclick="withdrawStars()">–í–´–í–ï–°–¢–ò –í–°–ï</button>
    </div>

    <!-- GAME -->
    <div id="screen-game" class="screen" style="justify-content: flex-start; padding-top: 20px;">
        <div class="game-header">
            <span id="game-title">GAME</span>
            <span id="score-display" style="color: gold;">SCORE: 0</span>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div class="ctrl-btn" style="grid-column: 1;" onmousedown="handleInput('left')" ontouchstart="handleInput('left', event)">‚Üê</div>
            <div class="ctrl-btn" style="grid-column: 2;" onmousedown="handleInput('up')" ontouchstart="handleInput('up', event)">‚Üª</div>
            <div class="ctrl-btn" style="grid-column: 3;" onmousedown="handleInput('right')" ontouchstart="handleInput('right', event)">‚Üí</div>
            <div class="ctrl-btn" style="grid-column: 2;" onmousedown="handleInput('down')" ontouchstart="handleInput('down', event)">‚Üì</div>
        </div>
    </div>
</div>

<!-- BET MODAL -->
<div id="bet-modal" class="modal">
    <div class="modal-content">
        <h3>–°–¢–ê–í–ö–ê</h3>
        <div class="btn-grid">
            <button class="btn btn-small" onclick="createDuel(10)">10</button>
            <button class="btn btn-small" onclick="createDuel(50)">50</button>
            <button class="btn btn-small" onclick="createDuel(100)">100</button>
            <button class="btn btn-small" onclick="createDuel(500)">500</button>
            <button class="btn btn-small" onclick="createDuel(1000)">1000</button>
        </div>
        <button class="btn" onclick="document.getElementById('bet-modal').style.display='none'" style="margin-top: 20px; border-color: red;">–û–¢–ú–ï–ù–ê</button>
    </div>
</div>

<!-- GAME OVER -->
<div id="game-over-modal" class="modal">
    <div class="modal-content">
        <h2 style="color: red;">GAME OVER</h2>
        <h3 id="final-score">Score: 0</h3>
        <p id="pvp-message" style="color: gold; font-size: 0.8rem;"></p>
        <button class="btn" onclick="location.reload()">–í –ú–ï–ù–Æ</button>
    </div>
</div>

<div class="nav-tabs">
    <div class="tab active" onclick="showScreen('menu'); updateTab(this)">–ê–†–ï–ù–ê</div>
    <div class="tab" onclick="showScreen('profile'); updateTab(this)">–ü–†–û–§–ò–õ–¨</div>
</div>

<script>
    // --- –ö–û–ù–§–ò–ì ---
    const API_URL = "https://tg-game-arena.onrender.com";
    const tg = window.Telegram.WebApp;
    tg.ready(); tg.expand();
    tg.setHeaderColor('#0d0d15'); tg.setBackgroundColor('#0d0d15');

    // --- –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
    let currentUser = null;
    let currentLobby = null;
    let gameLoop = null;
    let currentGame = '';
    let score = 0;

    // --- INIT ---
    async function init() {
        try {
            // 1. Auth
            const res = await fetch(`${API_URL}/api/user-data`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ initData: tg.initData })
            });
            currentUser = await res.json();
            updateProfile();

            // 2. Deep Link (Duel)
            const startParam = tg.initDataUnsafe.start_param;
            if (startParam) {
                const joinRes = await fetch(`${API_URL}/api/join-lobby`, {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ telegramId: currentUser.telegramId, startParam })
                });
                const joinData = await joinRes.json();
                
                if (joinData.error) {
                    tg.showAlert(joinData.error);
                } else if (joinData.mode === 'duel') {
                    currentLobby = joinData.lobby;
                    document.getElementById('duel-info').innerText = `üî• –î–£–≠–õ–¨: ${currentLobby.betAmount} STARS`;
                    launchGame('tetris', true);
                }
            }
        } catch (e) { console.error("Init failed", e); }
    }
    init();

    // --- UI ---
    function showScreen(name) {
        document.querySelectorAll('.screen').forEach(el => el.classList.remove('active'));
        document.getElementById(`screen-${name}`).classList.add('active');
        document.querySelector('.nav-tabs').style.display = (name === 'game') ? 'none' : 'flex';
        if (name !== 'game') stopGame();
    }
    function updateTab(el) {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        el.classList.add('active');
    }
    function updateProfile() {
        if (!currentUser) return;
        document.getElementById('p-id').innerText = currentUser.telegramId;
        document.getElementById('p-balance').innerText = currentUser.balance;
        document.getElementById('p-snake').innerText = currentUser.highScores.snake;
        document.getElementById('p-tetris').innerText = currentUser.highScores.tetris;
    }
    function openBetModal() { document.getElementById('bet-modal').style.display = 'flex'; }

    // --- PAYMENTS ---
    async function buyStars(amount) {
        try {
            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: —Å—Ä–∞–∑—É –≤—ã–∑—ã–≤–∞–µ–º –ø–ª–∞—Ç–µ–∂
            const res = await fetch(`${API_URL}/api/create-invoice`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, amount })
            });
            const data = await res.json();
            if (data.invoiceLink) {
                tg.openInvoice(data.invoiceLink, (status) => {
                    if (status === 'paid') {
                        tg.showAlert('–û–ø–ª–∞—Ç–∞ –ø—Ä–æ—à–ª–∞!');
                        currentUser.balance += amount; // –í–∏–∑—É–∞–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º
                        updateProfile();
                    }
                });
            } else {
                tg.showAlert('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏');
            }
        } catch (e) { tg.showAlert('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º'); }
    }

    async function createDuel(amount) {
        if (currentUser.balance < amount) return tg.showAlert("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!");
        try {
            const res = await fetch(`${API_URL}/api/create-lobby`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, betAmount: amount })
            });
            const data = await res.json();
            if (data.success) {
                const link = `https://t.me/share/url?url=https://t.me/RetroBattleBot/app?startapp=${data.lobbyId}&text=–ò–≥—Ä–∞–µ–º –Ω–∞ ${amount} Stars!`;
                tg.openTelegramLink(link);
            }
        } catch (e) { tg.showAlert("–û—à–∏–±–∫–∞ —Å–µ—Ç–∏"); }
    }

    async function withdrawStars() {
        if (!confirm("–í—ã–≤–µ—Å—Ç–∏ –≤—Å–µ?")) return;
        try {
            const res = await fetch(`${API_URL}/api/withdraw`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId })
            });
            const data = await res.json();
            if (data.success) {
                tg.showAlert("–ó–∞—è–≤–∫–∞ —Å–æ–∑–¥–∞–Ω–∞!");
                currentUser.balance = 0;
                updateProfile();
            }
        } catch (e) {}
    }

    // --- GAMES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const BLOCK = 20; 
    canvas.width = 200; canvas.height = 400; // 10x20 blocks

    function launchGame(game, isPvP) {
        currentGame = game;
        showScreen('game');
        document.getElementById('game-title').innerText = isPvP ? "PVP DUEL" : game.toUpperCase();
        document.getElementById('game-over-modal').style.display = 'none';
        score = 0;
        document.getElementById('score-display').innerText = `SCORE: 0`;

        if (game === 'snake') startSnake();
        if (game === 'tetris') startTetris();
    }

    function stopGame() {
        if (gameLoop) cancelAnimationFrame(gameLoop);
        clearTimeout(gameLoop);
    }

    async function gameOver() {
        stopGame();
        document.getElementById('final-score').innerText = score;
        document.getElementById('game-over-modal').style.display = 'flex';
        
        if (currentLobby) {
            document.getElementById('pvp-message').innerText = "–†–µ–∑—É–ª—å—Ç–∞—Ç –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è...";
            await fetch(`${API_URL}/api/submit-score`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, game: currentGame, score, lobbyId: currentLobby.lobbyId })
            });
            document.getElementById('pvp-message').innerText = "–†–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ø–∏—Å–∞–Ω!";
        } else {
            document.getElementById('pvp-message').innerText = "–¢—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
            fetch(`${API_URL}/api/submit-score`, {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ telegramId: currentUser.telegramId, game: currentGame, score })
            });
        }
    }

    function handleInput(action, e) {
        if (e) e.preventDefault();
        const keyMap = { 'left': 'ArrowLeft', 'right': 'ArrowRight', 'up': 'ArrowUp', 'down': 'ArrowDown' };
        document.dispatchEvent(new KeyboardEvent('keydown', { key: keyMap[action] }));
    }

    // --- SNAKE ENGINE (FIXED) ---
    function startSnake() {
        let snake = [{x: 5, y: 10}];
        let food = {x: 2, y: 2};
        let dx = 0, dy = 0;
        let gridSize = 20;
        let tileX = 10, tileY = 20;

        function spawnFood() {
            food = {
                x: Math.floor(Math.random() * tileX),
                y: Math.floor(Math.random() * tileY)
            };
        }

        document.onkeydown = (e) => {
            if (currentGame !== 'snake') return;
            switch(e.key) {
                case 'ArrowLeft': if(dx !== 1) { dx = -1; dy = 0; } break;
                case 'ArrowRight': if(dx !== -1) { dx = 1; dy = 0; } break;
                case 'ArrowUp': if(dy !== 1) { dx = 0; dy = -1; } break;
                case 'ArrowDown': if(dy !== -1) { dx = 0; dy = 1; } break;
            }
            // Start on press
            if (dx === 0 && dy === 0 && e.key) { dx = 0; dy = 1; }
        };

        function loop() {
            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Wall Collision
            if (head.x < 0 || head.x >= tileX || head.y < 0 || head.y >= tileY) {
                if (dx !== 0 || dy !== 0) { gameOver(); return; }
            }
            // Self Collision
            if (snake.some(s => s.x === head.x && s.y === head.y) && (dx!==0 || dy!==0)) {
                gameOver(); return;
            }

            if (dx!==0 || dy!==0) snake.unshift(head);

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                document.getElementById('score-display').innerText = `SCORE: ${score}`;
                spawnFood();
            } else if (dx!==0 || dy!==0) {
                snake.pop();
            }

            // Draw
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw Food (RED)
            ctx.fillStyle = 'red';
            ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);

            // Draw Snake (BLUE)
            ctx.fillStyle = '#00f0ff';
            snake.forEach(s => ctx.fillRect(s.x * gridSize, s.y * gridSize, gridSize - 2, gridSize - 2));
        }

        if (gameLoop) clearInterval(gameLoop);
        gameLoop = setInterval(loop, 150);
    }

    // --- TETRIS ENGINE (MATRIX BASED) ---
    function startTetris() {
        const ROW = 20, COL = 10, SQ = 20;
        const VACANT = "#000";
        let board = [];
        for(let r=0; r<ROW; r++){
            board[r] = [];
            for(let c=0; c<COL; c++) board[r][c] = VACANT;
        }

        const PIECES = [
            [[1,1,1,1]], // I
            [[1,1,1],[0,1,0]], // T
            [[1,1],[1,1]], // O
            [[1,1,0],[0,1,1]], // Z
            [[0,1,1],[1,1,0]], // S
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]]  // J
        ];
        const COLORS = ["cyan", "purple", "yellow", "red", "green", "orange", "blue"];

        let p = randomPiece();
        let dropStart = Date.now();

        function drawSquare(x,y,color){
            ctx.fillStyle = color; ctx.fillRect(x*SQ,y*SQ,SQ,SQ);
            ctx.strokeStyle = "#111"; ctx.strokeRect(x*SQ,y*SQ,SQ,SQ);
        }
        function drawBoard(){
            for(let r=0; r<ROW; r++)
                for(let c=0; c<COL; c++) drawSquare(c,r,board[r][c]);
        }
        function drawPiece(piece){
            for(let r=0; r<piece.matrix.length; r++){
                for(let c=0; c<piece.matrix[r].length; c++){
                    if(piece.matrix[r][c]) drawSquare(piece.x+c, piece.y+r, piece.color);
                }
            }
        }
        function randomPiece(){
            let r = Math.floor(Math.random() * PIECES.length);
            return { matrix: PIECES[r], color: COLORS[r], x: 3, y: 0 };
        }

        function move(dir) {
            if (!collision(dir, 0, p.matrix)) p.x += dir;
        }
        function rotate() {
            let N = p.matrix.length;
            let rotated = [];
            for(let i=0; i<N; i++) { // Transpose & Reverse
                rotated[i] = [];
                for(let j=0; j<p.matrix[0].length; j++) rotated[i][j] = p.matrix[N-1-j][i] || 0; // Simplified rotation
            }
            // Better rotation logic for non-square matrices
            if (p.matrix.length === 2 && p.matrix[0].length === 2) return; // O piece
            
            // Standard rotation algorithm
            let temp = p.matrix[0].map((val, index) => p.matrix.map(row => row[index]).reverse());
            
            if (!collision(0, 0, temp)) p.matrix = temp;
            else if (!collision(1, 0, temp)) { p.x += 1; p.matrix = temp; }
            else if (!collision(-1, 0, temp)) { p.x -= 1; p.matrix = temp; }
        }

        function collision(x,y,matrix){
            for(let r=0; r<matrix.length; r++){
                for(let c=0; c<matrix[r].length; c++){
                    if(!matrix[r][c]) continue;
                    let newX = p.x + c + x;
                    let newY = p.y + r + y;
                    if(newX < 0 || newX >= COL || newY >= ROW) return true;
                    if(newY < 0) continue;
                    if(board[newY][newX] !== VACANT) return true;
                }
            }
            return false;
        }

        function lock(){
            for(let r=0; r<p.matrix.length; r++){
                for(let c=0; c<p.matrix[r].length; c++){
                    if(!p.matrix[r][c]) continue;
                    if(p.y+r < 0) { gameOver(); return; }
                    board[p.y+r][p.x+c] = p.color;
                }
            }
            // Remove lines
            for(let r=0; r<ROW; r++){
                let isFull = true;
                for(let c=0; c<COL; c++) isFull = isFull && (board[r][c] !== VACANT);
                if(isFull){
                    for(let y=r; y>1; y--) for(let c=0; c<COL; c++) board[y][c] = board[y-1][c];
                    for(let c=0; c<COL; c++) board[0][c] = VACANT;
                    score += 100;
                    document.getElementById('score-display').innerText = `SCORE: ${score}`;
                }
            }
            p = randomPiece();
            if(collision(0,0,p.matrix)) gameOver();
        }

        function update(){
            let now = Date.now();
            if(now - dropStart > 600){
                if(!collision(0,1,p.matrix)) p.y++;
                else lock();
                dropStart = Date.now();
            }
            drawBoard();
            drawPiece(p);
            gameLoop = requestAnimationFrame(update);
        }

        document.onkeydown = (e) => {
            if(currentGame !== 'tetris') return;
            if(e.key === 'ArrowLeft') move(-1);
            else if(e.key === 'ArrowRight') move(1);
            else if(e.key === 'ArrowUp') rotate();
            else if(e.key === 'ArrowDown') {
                 if(!collision(0,1,p.matrix)) p.y++;
            }
        };
        
        if (gameLoop) cancelAnimationFrame(gameLoop);
        update();
    }
</script>
</body>
</html>
